@using System.Text.Json
@using Syncfusion.Blazor.Buttons
@using System.Collections.Generic
@using Syncfusion.Blazor.DropDowns
@using Syncfusion.Blazor.Inputs
@using Syncfusion.Blazor.Popups;
@using Syncfusion.Blazor.Navigations
@using Syncfusion.Blazor.Diagram
@using System.Collections.ObjectModel
@using Newtonsoft.Json.Linq;
@using Syncfusion.Blazor.SplitButtons
@using System.Drawing
@inject IJSRuntime js

@namespace MindMap

<div id='mindMapContainer' class="db-mindmap-prop-container" style="display:@MindMapPropertyVisibility">
    <div class="row db-prop-header-text">
        Properties
    </div>
    <div class="db-prop-separator"></div>
    <div class="row db-prop-header-text">
        Orientation Styles
    </div>
    <div class="row db-prop-row">
        <div class="col-xs-6 org-pattern-parent">
            <div class="mindmap-pattern-style mindmap-pattern1" @onclick="@MindmapPattern1Change" value=@PatternValue></div>
        </div>
        <div class="col-xs-6 org-pattern-parent">
            <div class="mindmap-pattern-style mindmap-pattern2" @onclick="@MindmapPattern2Change" value=@PatternValue></div>
        </div>
    </div>
    <div class="row db-prop-row" style="margin-top:5px">
        <div class="col-xs-6 org-pattern-parent">
            <div class="mindmap-pattern-style mindmap-pattern3" @onclick="@MindmapPattern3Change" value=@PatternValue></div>
        </div>
        <div class="col-xs-6 org-pattern-parent">
            <div class="mindmap-pattern-style mindmap-pattern4" @onclick="@MindmapPattern4Change" value=@PatternValue></div>
        </div>
    </div>
    <div class="db-prop-separator">
    </div>
    <div class="row db-prop-header-text">
        MindMap Levels Styles
    </div>
    <div class="row db-prop-row">
        <div  class="col-xs-6 db-col-left" style="width: 98%;">
            <SfDropDownList TValue="string" TItem="DefaultDropDownField" PopupHeight="230px" @bind-DataSource="@MindMapLevels" @bind-Value="@mindMapLevelValue">
                <DropDownListFieldSettings Text="Text" Value="Value"></DropDownListFieldSettings>
                <DropDownListEvents TItem="DefaultDropDownField" TValue="string" ValueChange="@OnMindMapLevelChange"></DropDownListEvents>
            </SfDropDownList>
        </div>
    </div>
    <div class="row db-prop-row" style="width:100%">
        <div class="col-xs-6 db-col-left" style="width:50%">
            <span class="db-prop-text-style">Shape</span>
        </div>
        <div class="col-xs-6 db-col-right" style="padding-left: 50px;">
            <span class="db-prop-text-style">Fill Color</span>
        </div>
    </div>
    <div id='mindMapShapes' class="row db-prop-row" style="padding-top: 5px; display: flex; align-items: center;">
        <div  class="col-xs-6 db-col-left" style="width:98%">
            <SfDropDownList TValue="string" TItem="MindMapShapes" PopupHeight="230px" @bind-DataSource="@MindMapShapesDataSource" @bind-Value="@mindMapShapeValue">
                <DropDownListFieldSettings Text="Text" Value="Value"></DropDownListFieldSettings>
                <DropDownListEvents TItem="MindMapShapes" TValue="string" ValueChange="@OnMindMapShapeChange"></DropDownListEvents>
            </SfDropDownList>
        </div>
        <div  class="col-xs-6 db-col-right" style="padding-left: 10px;">
            <SfColorPicker ID="mindmapFill" Mode="ColorPickerMode.Palette" ValueChange="@OnFillColorChange" @bind-Value="@fillColorValue"></SfColorPicker>
        </div>
    </div>
    <div class="row db-border-style">
        <div class="row db-prop-header-text db-border-style-header">
            Border/Line Styles
        </div>
        <div class="row db-prop-row" style="width:100%">
            <div class="col-xs-6 db-col-right">
                <span class="db-prop-text-style">Type</span>
            </div>
            <div class="col-xs-2 db-col-center" style="margin-left: -30px; ">
                <span class="db-prop-text-style">Stroke</span>
            </div>
            <div class="col-xs-2 db-col-left" style="margin-left: 25px">
                <span class="db-prop-text-style">Thickness</span>
            </div>
        </div>
    <div class="row">
            <div  class="col-xs-6 db-col-left" style="width:90px;margin-top:3px">
            <SfDropDownList ID="strokeStyle" TValue="string" TItem="BorderStylesFields" PopupWidth="160px" Index="@strokeStyleValue" DataSource="@BorderStyles">
                <DropDownListTemplates TItem="BorderStylesFields">
                    <ItemTemplate>
                        <div class='db-ddl-template-style'>
                            <span class=@((context as BorderStylesFields).ClassName)></span>
                        </div>
                    </ItemTemplate>
                    <ValueTemplate>
                        <div class='db-ddl-template-style'>
                            <span class=@((context as BorderStylesFields).ClassName)></span>
                        </div>
                    </ValueTemplate>
                </DropDownListTemplates>
                <DropDownListEvents TValue="string" TItem="BorderStylesFields" ValueChange="@OnStrokeDashArrayChange"></DropDownListEvents>
                <DropDownListFieldSettings Text="Text" Value="Value"></DropDownListFieldSettings>
            </SfDropDownList>
        </div>
            <div  class="col-xs-2 db-col-center" style="margin-top:4px">
                <div style="width:50px;margin-left:8px">
                    <SfColorPicker ID="mindmapStroke" ValueChange="OnStrokeColorChange" Mode="ColorPickerMode.Palette" @bind-Value="@strokeColorValue"></SfColorPicker>
            </div>
        </div>
            <div class="col-xs-4 db-col-center" style="width:87px;margin-left: 34px;margin-top:4px;">
                <SfNumericTextBox ID="mindmapStrokeWidth" Format="###.##" Min="0" Step="0.5" @bind-Value="@mindMapStrokeWidth">
                <NumericTextBoxEvents TValue="double" ValueChange="@OnStrokeWidthChange"></NumericTextBoxEvents>
            </SfNumericTextBox>
        </div>
    </div>
    </div>
    <div class="row db-prop-row">
        <div class="col-xs-2 db-col-right db-prop-text-style" style="margin-right: 15px;padding-top: 6px">
            <span class="db-prop-text-style">Opacity</span>
        </div>
        <div class="col-xs-8 db-col-left" style="padding-right:10px">
            <SfSlider ID="mindmapOpacitySlider" @ref="SfSlide" Type="SliderType.MinRange" @bind-Value="@mindMapOpacity" Min="0" Max="100" Step="10">
                <SliderEvents TValue="double" OnChange="@(e => { OnMindMapOpacityChange(e.Value); })"></SliderEvents>
            </SfSlider>
        </div>
        <div class="col-xs-2 db-col-right" style="margin-left: -15px;padding-left: 8px">
            <input type="text" readOnly="readonly" value="@mindMapOpacity" id="mindmapOpacityText" class="db-readonly-input" />
        </div>
    </div>
    <div class="db-prop-separator">
    </div>
    <div class="row db-prop-header-text">
        Connector Type
    </div>
    <div class="row db-prop-row">
        <div class="col-xs-3 db-prop-col-style" style="margin-right: 8px;width: 30%;">
            <SfRadioButton Name="connectorType" TChecked="bool" TValue="bool" Label="Bezier" @bind-Checked="@bezierChecked" @onchange="@OnBezierChange" Value="true"></SfRadioButton>
        </div>
        <div class="col-xs-3 db-prop-col-style">
            <SfRadioButton Name="connectorType" TChecked="bool" TValue="bool" Label="Straight" @bind-Checked="@bezierChecked" @onchange="@OnStraightChange" Value="false"></SfRadioButton>
        </div>
    </div>
    <div class="db-prop-separator">
    </div>
    <div style="margin-top:10px;margin-bottom: 15px"></div>
    <div class="row db-prop-header-text">
        Text Style
    </div>
    <div class="row db-prop-row">
        <div class="col-xs-6 db-col-left" style="width:50%">
            <SfDropDownList ID="MindmapFontFamilyList" TValue="string" TItem="FontFamilyListFields" DataSource="@FontFamilyList" @bind-Value="@TextFontFamily">
                <DropDownListFieldSettings Text="Text" Value="Value"></DropDownListFieldSettings>
                <DropDownListEvents TValue="string" TItem="FontFamilyListFields" ValueChange="@OnFontFamilyChange"></DropDownListEvents>
            </SfDropDownList>
        </div>
        <div class="col-xs-6 db-col-right" style="padding-left: 10px;">
            <SfNumericTextBox ID="MindmapFontSize" Format="###.##" Min="1" Step="1" @bind-Value="@TextFontSize">
                <NumericTextBoxEvents TValue="double" ValueChange="@OnTextFontSizeChanged"></NumericTextBoxEvents>
            </SfNumericTextBox>
        </div>
    </div>
    <div class="row db-prop-row" style="padding-top: 5px; display: flex; align-items: center;">
        <div class="col-xs-6 db-col-left" style=" min-height:auto;height:auto;width:80%;background: #e3e3e3;">
            <SfToolbar ID="MindmapTextStyleToolbar" >
                <ToolbarEvents Clicked="@OnTextStyleClick"></ToolbarEvents>
                <ToolbarItems >
                    <ToolbarItem PrefixIcon="e-icons e-bold" TooltipText="Bold" CssClass="@BoldCss"></ToolbarItem>
                    <ToolbarItem PrefixIcon="e-icons e-italic" TooltipText="Italic" CssClass="@ItalicCss"></ToolbarItem>
                    <ToolbarItem PrefixIcon="e-icons e-underline" TooltipText="Underline" CssClass="@UnderlineCss"></ToolbarItem>
                </ToolbarItems>
            </SfToolbar>
        </div>
        <div class="col-xs-6 db-col-right" id="textColorDiv" style="padding-left: 10px;">
            <SfColorPicker ID="mindmapTextColor" @bind-Value="@TextColor" Mode="ColorPickerMode.Palette" ValueChange="@OnTextColorChange"></SfColorPicker>
        </div>
    </div>
    <div class="row db-prop-row">
        <div class="col-xs-2 db-col-right db-prop-text-style" style="margin-right: 15px;padding-top: 6px">
            <span class="db-prop-text-style">Opacity</span>
        </div>
        <div class="col-xs-8 db-col-left" style="padding-right:10px">
            <SfSlider ID="mindmapTextOpacitySlider" @ref="OpacitySfSlide" Type="SliderType.MinRange" @bind-Value="@TextOpacity" Min="0" Max="100" Step="10">
                <SliderEvents TValue="double" OnChange="@(e => { OnTextOpacityChange(e.Value); })"></SliderEvents>
            </SfSlider>
        </div>
        <div class="col-xs-2 db-col-right" style="margin-left: -15px;padding-left: 8px">
            <input type="text" id="textNodeOpacityText" value="@TextOpacity" class="db-readonly-input" readOnly="readonly" />
        </div>
    </div>
    <div class="db-prop-separator">
    </div>
    <div class="row db-prop-row">
        <div class="col-xs-8 db-col-right db-prop-text-style" style="padding-top: 12px;">
            <span class="db-prop-text-style">Horizontal Spacing</span>
        </div>
        <div  class="col-xs-4 db-col-left" style="padding-top: 8px">
            <SfNumericTextBox TValue="int?" Width="100%" @bind-Value="@horizontalValue" Min="20" Step="2" Format="###.##">
                <NumericTextBoxEvents TValue="int?" ValueChange="OnHorizontalSpaceChange"></NumericTextBoxEvents>
            </SfNumericTextBox>
        </div>
    </div>
    <div class="row db-prop-row">
        <div class="col-xs-8 db-col-right db-prop-text-style" style="padding-top: 12px;">
            <span class="db-prop-text-style">Vertical Spacing</span>
        </div>
        <div  class="col-xs-4 db-col-left" style="padding-top: 8px;">
            <SfNumericTextBox TValue="int?" Width="100%" @bind-Value="@verticalValue" Min="20" Step="2" Format="###.##">
                <NumericTextBoxEvents TValue="int?" ValueChange="OnVerticalSpaceChange"></NumericTextBoxEvents>
            </SfNumericTextBox>
        </div>
    </div>
     <div class="row db-prop-row">
            <div class="col-xs-8 db-col-left" style="margin-top:5px">
            <SfCheckBox Label="Expandable" @bind-Checked="@OnExpandable" @onchange="@OnExpandableChange"></SfCheckBox>
            </div>
        </div>
</div>
<div id='multipleChild' class="db-mindmap-prop-container" style="display:@MultipleChildContainerVisibility">
    <div class="row db-prop-header-text" value=@PatternValue>
        Add Multiple Child
    </div>
    <div class="col-xs-12 db-col-right db-prop-text-style" style="padding-top: 10px">
        Please enter one by one
    </div>
    <div class="row db-prop-row" style="padding-top: 10px">
        <SfTextBox @ref="textBox" Height="350px" Enabled="@CheckDisabled" ValueChanged="@ValueChangedHandler" floatLabelType="@floatLabel" Multiline="true" CssClass="e-corner" style="border: 1px solid black; height:270px; background:white;"></SfTextBox>
        <div id='ChildAdd' class="row db-prop-row">
            <div class="col-xs-6 db-col-left" style="float:left">
                <SfButton CssClass="e-outline" @onclick="Cancel">Cancel</SfButton>
            </div>
            <div class="col-xs-6 db-col-right" style="float:right">
                <SfButton IsPrimary="true" CssClass="e-outline" @onclick="AddChild">Add</SfButton>
            </div>
        </div>
    </div>
</div>
<style>
    .e-input-group.e-corner {
        border-radius: 4px;
    }
</style>


@code {
    #pragma warning disable BL0005
    /// <summary>
    /// Represents the parent DiagramMain instance.
    /// </summary>
    internal DiagramMain Parent;
    /// <summary>
    /// Represents the SfSlider instance for a double value.
    /// </summary>
    SfSlider<double> SfSlide;
    /// <summary>
    /// Represents the SfSlider instance for opacity with a double value.
    /// </summary>
    SfSlider<double> OpacitySfSlide;
    /// <summary>
    /// Represents the SfTextBox instance.
    /// </summary>
    SfTextBox textBox;
    /// <summary>
    /// The horizontal spacing value of mind map layout.
    /// </summary>
    int? horizontalValue = 50;
    /// <summary>
    /// The vertical spacing value of mind map layout.
    /// </summary>
    int? verticalValue = 50;
    /// <summary>
    /// Class name for text changing Bold icon
    /// </summary>
    string BoldCss = "tb-item-start";
    /// <summary>
    /// Class name for text changing Italian icon
    /// </summary>
    string ItalicCss = "tb-item-middle";
    /// <summary>
    /// Class name for text changing Undeerline icon
    /// </summary>
    string UnderlineCss = "tb-item-end";
    /// <summary>
    /// Gets or sets the value of the text font family.
    /// </summary>
    string TextFontFamily { get; set; }
    /// <summary>
    /// Represents the color of the text.
    /// </summary>
    string TextColor { get; set; }
    /// <summary>
    /// Represents the font size of the text.
    /// </summary>
    double TextFontSize { get; set; }
    /// <summary>
    /// Represents the font size of the text.
    /// </summary>
    double TextOpacity { get; set; }
    /// <summary>
    /// Represents the default template type.
    /// </summary>
    private string templateType = "Template1";
    /// <summary>
    /// Represents an array of fill colors.
    /// </summary>
    private string[] fillColorCode = { "#C4F2E8", "#F7E0B3", "#E5FEE4", "#E9D4F1", "#D4EFED", "#DEE2FF" };
    /// <summary>
    /// Indicates whether the floatable type option is enabled or not.
    /// </summary>
    private bool CheckDisabled { get; set; } = true;
    /// <summary>
    /// Represents the stroke dash array value.
    /// </summary>
    private string strokeDashArrayValue { get; set; } = "";
    /// <summary>
    /// Represents the stroke dash array value.
    /// </summary>
    private int strokeStyleValue { get; set; } = 0;
    /// <summary>
    /// Represents an array of border colors.
    /// </summary>
    private string[] borderColorCode = { "#8BC1B7", "#E2C180", "#ACCBAA", "#D1AFDF", "#90C8C2", "#BBBFD6" };
    /// <summary>
    /// Represents a collection of NodeBase used for pasting data.
    /// </summary>
    private DiagramObjectCollection<NodeBase> pasteData = new DiagramObjectCollection<NodeBase>();
    /// <summary>
    /// Indicates whether the layout element is copied.
    /// </summary>
    private bool IsCopyLayoutElement = false;
    /// <summary>
    /// Represents the last fill index, an integer.
    /// </summary>

    private int lastFillIndex = 0;
    /// <summary>
    /// Represents the layout levels in property panel.
    /// </summary>
    private string LevelType = "Level0";
    /// <summary>
    /// Specifies the segment type of the connector.
    /// </summary>
    private ConnectorSegmentType connectorType = ConnectorSegmentType.Bezier;
    /// <summary>
    /// Represents the type of the level in the mind map.
    /// </summary>
    private string mindMapLevel;
    /// <summary>
    /// Represents the FloatLabelType for the float label.
    /// </summary>
    private FloatLabelType floatLabel { get; set; } = FloatLabelType.Auto;
    /// <summary>
    /// Represents the value for the mind map level.
    /// </summary>
    private string mindMapLevelValue { get; set; } 
    /// <summary>
    /// Represents the value for the node shape.
    /// </summary>
    private string mindMapShapeValue { get; set; } 
    /// <summary>
    /// Represents the value for the node fill color.
    /// </summary>
    private string fillColorValue { get; set; } 
    /// <summary>
    /// Represents the value for the node stroke color.
    /// </summary>
    private string strokeColorValue { get; set; }
    /// <summary>
    /// Represents the value for the node stroke width.
    /// </summary>
    private double mindMapStrokeWidth { get; set; } = 1;
    /// <summary>
    /// Represents the value for the opacity of the node.
    /// </summary>
    private double mindMapOpacity { get; set; }
    /// <summary>
    /// Indicates whether the bezier option is checked, a boolean value.
    /// </summary>
    private bool bezierChecked { get; set; } = true; 
    /// <summary>
    /// Indicates whether there is a pattern change, a boolean value.
    /// </summary>
    public bool PatternChange = false;

    /// <summary>
    /// Indicates whether property changes are prevented, a boolean value.
    /// </summary>
    public bool PreventPropertyChange { get; set; } = false;
    /// <summary>
    /// Indicates whether there is a mind map property visibility.
    /// </summary>
    public string MindMapPropertyVisibility { get; set; } = "block";
    /// <summary>
    /// Indicates whether there is a mind map child node adding property panel visibility.
    /// </summary>
    public string MultipleChildContainerVisibility { get; set; } = "none";
    /// <summary>
    /// Indicates whether there is a mind map property is visible or not.
    /// </summary>
    public bool MindMapProperty = true;
    /// <summary>
    /// Indicates whether there is a expandable option is checked or not.
    /// </summary>
    public bool OnExpandable = false;
    /// <summary>
    /// Represents the value for the value of copied items.
    /// </summary>
    public Node PastedFirstItem = null;
    /// <summary>
    /// Indicates whether there is a mindmap layout or not.
    /// </summary>
    public bool IsMindMap = true;
    public string[] Children;
    /// <summary>
    /// Represents the value for the change the mindmap patterns.
    /// </summary>
    public string PatternValue = "None";
    /// <summary>
    /// Represents a class that holds the text and value for the dropdown fields.
    /// </summary>
    public class DefaultDropDownField
    {
        public string Value { get; set; } = "";
        public string Text { get; set; } = "";
    }
    /// <summary>
    /// Represents a list of DefaultDropDownField for the mind map levels.
    /// </summary>
    public List<DefaultDropDownField> MindMapLevels = new List<DefaultDropDownField>()
    {
        new DefaultDropDownField(){ Text= "Root", Value= "Level0" },
        new DefaultDropDownField(){ Text= "Level1", Value= "Level1" },
        new DefaultDropDownField(){ Text= "Level2", Value="Level2" },
        new DefaultDropDownField(){ Text= "Level3", Value="Level3" },
        new DefaultDropDownField(){ Text= "Level4", Value="Level4" },
        new DefaultDropDownField(){ Text= "Level5", Value="Level5" },
        new DefaultDropDownField(){ Text= "Selected Item", Value="Selected Item" }
    };
    /// <summary>
    /// Represents a class that holds the text and value for the mind map shapes.
    /// </summary>
    public class MindMapShapes
    {
        public string Value { get; set; } = "";
        public string Text { get; set; } = "";
    }
    /// <summary>
    /// Represents a list of MindMapShapes for the mind map shapes.
    /// </summary>
    private List<MindMapShapes> MindMapShapesDataSource = new List<MindMapShapes>()
    {
        new MindMapShapes(){ Text= "Rectangle", Value= "Rectangle" },
        new MindMapShapes(){ Text= "Ellipse", Value= "Ellipse" },
        new MindMapShapes(){ Text= "Star", Value="Star" },
        new MindMapShapes(){ Text= "Cloud", Value="Cloud" },
        new MindMapShapes(){ Text= "Free hand", Value="Free hand" },
    };
    /// <summary>
    /// Represents a class for defining border styles.
    /// </summary>
    public class BorderStylesFields
    {
        public string Value { get; set; } = "";
        public string Text { get; set; } = "";
        public string ClassName { get; set; } = "";
    }
    /// <summary>
    /// Represents a list of border styles.
    /// </summary>
    public List<BorderStylesFields> BorderStyles = new List<BorderStylesFields>()
    {
        new BorderStylesFields() { Text= "None", Value="", ClassName="ddl-svg-style ddl_linestyle_none" },
        new BorderStylesFields() { Text= "1,2", Value="1,2", ClassName="ddl-svg-style ddl_linestyle_one_two" },
        new BorderStylesFields() { Text= "3,3", Value="3,3", ClassName="ddl-svg-style ddl_linestyle_three_three" },
        new BorderStylesFields() { Text= "5,3", Value="5,3", ClassName="ddl-svg-style ddl_linestyle_five_three" },
        new BorderStylesFields() { Text= "4,4,1", Value="4,4,1", ClassName="ddl-svg-style ddl_linestyle_four_four_one" }
    };
    /// <summary>
    /// Represents a class for defining font family options.
    /// </summary>
    public class FontFamilyListFields
    {
        public string Value { get; set; } = "";
        public string Text { get; set; } = "";
    }
    /// <summary>
    /// Represents a list of font family options.
    /// </summary>
    public List<FontFamilyListFields> FontFamilyList = new List<FontFamilyListFields>()
    {
        new FontFamilyListFields(){ Text= "Arial", Value= "Arial", },
        new FontFamilyListFields(){ Text= "Aharoni", Value= "Aharoni" },
        new FontFamilyListFields(){ Text= "Bell MT", Value="Bell MT" },
        new FontFamilyListFields(){ Text= "Fantasy", Value= "Fantasy" },
        new FontFamilyListFields(){ Text= "Times New Roman", Value= "Times New Roman" },
        new FontFamilyListFields(){ Text= "Segoe UI", Value="Segoe UI" },
        new FontFamilyListFields(){ Text= "Verdana", Value= "Verdana" }
    };
    /// <summary>
    /// Refresh the property panel items with it's initial value
    /// </summary>
    public void RefreshPanelItems()
    {
        SfDiagramComponent Diagram = Parent.DiagramContent.Diagram;
        mindMapLevelValue = "Root";
        mindMapShapeValue = "Ellipse";
        fillColorValue = Diagram.Nodes[0].Style.Fill.ToString();
        strokeColorValue = "#80BFEA";
        TextColor = "#008000";
        StateHasChanged();
    }

    /// <summary>
    /// To bind mindmap properties at initial rendering and selection
    /// </summary>
    public void bindMindMapProperties(Node? node = null)
    {
        SfDiagramComponent Diagram = Parent.DiagramContent.Diagram;
        IsMindMap = true;
        if (node == null)
        {
            if (Diagram.SelectionSettings.Nodes.Count > 0)
                node = Diagram.GetObject(Diagram.SelectionSettings.Nodes[0].ID) as Node;
            else if (mindMapLevel != null)
                node = GetNodeForPropertyChange();
            else
                node = Diagram.Nodes[0] as Node;
        }
        var obj = System.Text.Json.JsonSerializer.Serialize(node?.AdditionalInfo);
        NodeAddInfo NodeInfo = JsonSerializer.Deserialize<NodeAddInfo>(obj.ToString());
        if (LevelType != "Selected Item" && NodeInfo!=null)
        {
            mindMapLevelValue = "Level" + NodeInfo.Level;
            mindMapLevel = "Level" + NodeInfo.Level;
        };
        fillColorValue = node.Style.Fill;
        mindMapStrokeWidth = node.Style.StrokeWidth;
        strokeColorValue = node.Style.StrokeColor;
        strokeDashArrayValue = node.Style.StrokeDashArray;
        UpdateStrokeStyleValue(strokeDashArrayValue);
        mindMapOpacity = node.Style.Opacity * 100;
        mindMapShapeValue = bindShapeProperty(node);
        if (node.Annotations.Count > 0)
        {
            TextStyle Style = node.Annotations[0].Style;
            TextFontFamily = Style.FontFamily;
            TextFontSize = Style.FontSize;
            if (!Style.Color.Contains("#"))
            {
                int ColorValue = Color.FromName(Style.Color).ToArgb();
                string ColorHex = string.Format("{0:x6}", ColorValue);
                TextColor = "#" + ColorHex.Substring(2);
            }
            else
            {
                TextColor = Style.Color;
            }
            TextOpacity = Style.Opacity * 100;

            BoldCss = (Style.Bold) ? BoldCss + " tb-item-selected" : BoldCss.Replace(" tb-item-selected", "");
            ItalicCss = (Style.Italic) ? ItalicCss + " tb-item-selected" : ItalicCss.Replace(" tb-item-selected", "");
            UnderlineCss = (Style.TextDecoration == TextDecoration.Underline) ? UnderlineCss + " tb-item-selected" : UnderlineCss.Replace(" tb-item-selected", "");
        }
        StateHasChanged();
    }

    /// <summary>
    /// This method is used to update the expand and collapse icon for nodes.
    /// </summary>
    public async Task OnExpandableChange(Microsoft.AspNetCore.Components.ChangeEventArgs? args = null)
    {
        SfDiagramComponent Diagram = Parent.DiagramContent.Diagram;

        for (int i = 0; i < Diagram.Nodes.Count; i++)
        {
            Diagram.StartGroupAction();
            if (Diagram.Nodes[i].OutEdges.Count > 0)
            {
                Diagram.Nodes[i].IsExpanded = true;
                Diagram.Nodes[i].ExpandIcon.Shape = OnExpandable ? DiagramExpandIcons.Minus : DiagramExpandIcons.None;
                Diagram.Nodes[i].CollapseIcon.Shape = OnExpandable ? DiagramCollapseIcons.Plus : DiagramCollapseIcons.None;
            }
            Diagram.EndGroupAction();
            await Diagram.DoLayoutAsync();
        }
        Parent.MindMapPropertyPanel.StateHasChanged();
        Parent.DiagramContent.StateChanged();
        Parent.StateChanged();
    }
    /// <summary>
    /// This method is used to update selected Node's shape.
    /// </summary>

    private string bindShapeProperty(Node node)
    {
        if (node.Shape.Type == NodeShapes.Basic)
        {
            NodeBasicShapes Shape = (node.Shape as BasicShape).Shape;
            if (Shape == NodeBasicShapes.Ellipse)
                return "Ellipse";
            else
                return "Rectangle";
        }
        else if (node.Shape.Type == NodeShapes.Path)
        {
            string Data = (node.Shape as PathShape).Data;
            if (Data == "M28 1.60745L32.6757 7.49196L33.1063 8.03386L33.7651 7.82174L43.5571 4.66902L41.3666 9.9757L40.8265 11.2839L42.24 11.356L52.0141 11.8539L45.233 15.0979L43.3473 16L45.233 16.9021L52.0141 20.1461L42.24 20.644L40.8265 20.716L41.3666 22.0243L43.5571 27.331L33.7651 24.1783L33.1063 23.9661L32.6757 24.508L28 30.3926L23.3243 24.508L22.8937 23.9661L22.2349 24.1783L12.4429 27.331L14.6334 22.0243L15.1734 20.7161L13.7599 20.644L3.98585 20.1461L10.767 16.9021L12.6527 16L10.767 15.0979L3.98585 11.8539L13.7599 11.356L15.1734 11.2839L14.6334 9.9757L12.4429 4.66902L22.2349 7.82174L22.8937 8.03386L23.3243 7.49196L28 1.60745Z")
                return "Star";
            else if (Data == "M55.7315 17.239C57.8719 21.76 54.6613 27.788 47.1698 26.0787C46.0997 32.309 33.2572 35.323 28.9764 29.2951C25.7658 35.323 10.7829 33.816 10.7829 26.0787C3.29143 30.802 -0.989391 20.253 2.22121 17.239C-0.989317 14.2249 2.22121 6.68993 10.7829 8.39934C13.9935 -0.845086 25.7658 -0.845086 28.9764 5.18301C32.187 0.661909 45.0294 0.661908 47.1698 8.39934C52.5209 5.18301 60.0123 12.7179 55.7315 17.239Z")
                return "Cloud";
            else
                return "Free hand";
        }
        else
            return "Rectangle";
    }
    /// <summary>
    /// The below methods are used to updated the mind map patterns.
    /// </summary>
    #region
    private async Task MindmapPattern1Change()
    {
        await MindmapPatternChange("pattern1");
        PatternValue = "pattern1";
        PatternChange = true;
        bindMindMapProperties(GetNodeForPropertyChange());
    }
    private async Task MindmapPattern2Change()
    {
        await MindmapPatternChange("pattern2");
        PatternValue = "pattern2";
        PatternChange = true;
        bindMindMapProperties(GetNodeForPropertyChange());
    }
    private async Task MindmapPattern3Change()
    {
        Parent.DiagramContent.Diagram.BeginUpdate();
        await MindmapPatternChange("pattern3");
        await Parent.DiagramContent.Diagram.EndUpdateAsync();
        PatternValue = "pattern3";
        PatternChange = true;
        bindMindMapProperties(GetNodeForPropertyChange());
    }
    private async Task MindmapPattern4Change()
    {
        await MindmapPatternChange("pattern4");
        PatternValue = "pattern4";
        PatternChange = true;
        bindMindMapProperties(GetNodeForPropertyChange());
    }
    /// <summary>
    /// This method is used to update Node's shape and connector type based on the pattern selected
    /// </summary>
    public async Task MindmapPatternChange(string type)
    {
        connectorType = (type == "pattern2") ? ConnectorSegmentType.Orthogonal : ConnectorSegmentType.Bezier;
        Node node; Connector connector;
        SfDiagramComponent Diagram = Parent.DiagramContent.Diagram;
        Diagram.StartGroupAction();
        for (int i = 0; i < Diagram.Nodes.Count; i++)
        {
            node = Diagram.GetObject(Diagram.Nodes[i].ID) as Node;
            if (type == "pattern1")
            {
                if (node.ID == "rootNode")
                {
                    node.Height = 50;
                    node.Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Ellipse };
                }
                else
                {
                    node.Height = 30;
                    node.Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle };
                }
            }
            else if (type == "pattern2")
            {
                if (node.ID == "rootNode")
                {
                    node.Height = 50;
                    node.Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle, CornerRadius = 5 };
                }
                else
                {
                    node.Height = 30;
                    node.Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle };
                }
            }
            else if (type == "pattern3")
            {
                if (node.ID == "rootNode")
                {
                    node.Height = 50;
                    node.Shape = new PathShape() { Type = NodeShapes.Path, Data = "M55.7315 17.239C57.8719 21.76 54.6613 27.788 47.1698 26.0787C46.0997 32.309 33.2572 35.323 28.9764 29.2951C25.7658 35.323 10.7829 33.816 10.7829 26.0787C3.29143 30.802 -0.989391 20.253 2.22121 17.239C-0.989317 14.2249 2.22121 6.68993 10.7829 8.39934C13.9935 -0.845086 25.7658 -0.845086 28.9764 5.18301C32.187 0.661909 45.0294 0.661908 47.1698 8.39934C52.5209 5.18301 60.0123 12.7179 55.7315 17.239Z" };
                }
                else if (Convert.ToString(node.AdditionalInfo["Level"]) == "1")
                {
                    node.Height = 30;
                    node.Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Ellipse };
                }
                else if (Convert.ToString(node.AdditionalInfo["Level"]) == "2")
                {
                    node.Height = 30;
                    node.Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle };
                }
                else if (Convert.ToString(node.AdditionalInfo["Level"]) == "3")
                {
                    node.Height = 30;
                    node.Shape = new PathShape() { Type = NodeShapes.Path, Data = "M24.9123 3.78029C25.0975 4.3866 24.9466 4.88753 24.8501 5.15598L24.8444 5.17188L24.8379 5.18757C24.543 5.89091 23.7879 6.37572 22.9737 6.71397C22.1386 7.06093 21.0847 7.3197 19.9302 7.51132C17.6145 7.89568 14.7099 8.03929 11.8845 7.99097C9.05877 7.94266 6.24887 7.70127 4.11982 7.29202C3.06318 7.08891 2.11594 6.83369 1.41022 6.51281C0.766274 6.22 0 5.72087 0 4.9469C0 4.01004 0.964525 3.41277 1.79867 3.05724C2.70576 2.67063 3.89493 2.37901 5.11258 2.15935C7.44304 1.73893 10.1147 1.54134 11.7304 1.52346C11.8769 1.52184 12.0122 1.59735 12.0902 1.72133V1.72133C12.2554 1.98406 12.0895 2.33011 11.7819 2.37125C6.76467 3.04222 7.47107 3.02672 5.26455 3.42478C4.10916 3.63321 3.07622 3.89464 2.39298 4.18584C1.76916 4.45172 1.91438 4.9469 1.92108 4.92166C1.95272 4.95811 2.05541 5.05272 2.36059 5.19149C2.83828 5.4087 3.58481 5.6232 4.56968 5.81251C6.52366 6.18811 9.1877 6.42238 11.9256 6.4692C14.6639 6.51602 17.4127 6.37423 19.539 6.02131C20.6055 5.8443 21.4697 5.62145 22.0872 5.36491C22.7085 5.10676 22.9449 4.87196 23.0162 4.71867C23.0759 4.54803 23.1185 4.35742 23.052 4.13951C22.9867 3.92586 22.7842 3.58431 22.1006 3.17831C20.6845 2.3372 17.4158 1.34558 10.1686 0.773902C10.0395 0.763721 9.92243 0.68718 9.86361 0.571853V0.571853C9.7338 0.317364 9.92861 0.0177825 10.2139 0.0325302C17.4619 0.407187 21.4191 0.873597 23.2463 1.95885C24.2179 2.53589 24.7233 3.16153 24.9123 3.78029Z" };
                }
                else
                    node.Height = 4;
            }
            else
            {
                if (node.ID == "rootNode")
                {
                    node.Height = 50;
                    node.Shape = new PathShape() { Type = NodeShapes.Path, Data = "M28 1.60745L32.6757 7.49196L33.1063 8.03386L33.7651 7.82174L43.5571 4.66902L41.3666 9.9757L40.8265 11.2839L42.24 11.356L52.0141 11.8539L45.233 15.0979L43.3473 16L45.233 16.9021L52.0141 20.1461L42.24 20.644L40.8265 20.716L41.3666 22.0243L43.5571 27.331L33.7651 24.1783L33.1063 23.9661L32.6757 24.508L28 30.3926L23.3243 24.508L22.8937 23.9661L22.2349 24.1783L12.4429 27.331L14.6334 22.0243L15.1734 20.7161L13.7599 20.644L3.98585 20.1461L10.767 16.9021L12.6527 16L10.767 15.0979L3.98585 11.8539L13.7599 11.356L15.1734 11.2839L14.6334 9.9757L12.4429 4.66902L22.2349 7.82174L22.8937 8.03386L23.3243 7.49196L28 1.60745Z" };
                }
                else if (Convert.ToString(node.AdditionalInfo["Level"]) == "1")
                {
                    node.Height = 30;
                    node.Shape = new PathShape() { Type = NodeShapes.Path, Data = "M55.7315 17.239C57.8719 21.76 54.6613 27.788 47.1698 26.0787C46.0997 32.309 33.2572 35.323 28.9764 29.2951C25.7658 35.323 10.7829 33.816 10.7829 26.0787C3.29143 30.802 -0.989391 20.253 2.22121 17.239C-0.989317 14.2249 2.22121 6.68993 10.7829 8.39934C13.9935 -0.845086 25.7658 -0.845086 28.9764 5.18301C32.187 0.661909 45.0294 0.661908 47.1698 8.39934C52.5209 5.18301 60.0123 12.7179 55.7315 17.239Z" };
                }
                else if (Convert.ToString(node.AdditionalInfo["Level"]) == "2")
                {
                    node.Height = 30;
                    node.Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle };
                }
                else if (Convert.ToString(node.AdditionalInfo["Level"]) == "3")
                {
                    node.Height = 30;
                    node.Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Ellipse };
                }
                else
                    node.Height = 3;
            }
        }
        for (var i = 0; i < Diagram.Connectors.Count; i++)
        {
            connector = Diagram.GetObject(Diagram.Connectors[i].ID) as Connector;
            switch (type)
            {
                case "pattern1":
                    connector.Type = ConnectorSegmentType.Bezier;
                    templateType = "Template1";
                    break;
                case "pattern2":
                    connector.Type = ConnectorSegmentType.Orthogonal;
                    templateType = "Template4";
                    break;
                case "pattern3":
                    connector.Type = ConnectorSegmentType.Bezier;
                    templateType = "Template2";
                    break;
                case "pattern4":
                    connector.Type = ConnectorSegmentType.Bezier;
                    templateType = "Template3";
                    break;
            }
        }
        Diagram.EndGroupAction();
        await Diagram.DoLayoutAsync();
    }
    #endregion
     /// <summary>
    /// This method is used to refresh the mindmap property panel.
    /// </summary>
    public void StateHasChange()
    {
        StateHasChanged();
    }
    /// <summary>
    /// This method is used to update the connector type as Bezier.
    /// </summary>

    #region
    public async Task OnBezierChange(Microsoft.AspNetCore.Components.ChangeEventArgs args)
    {
        await OnUpdateConnectorType("Bezier", args.Value.ToString());
        PatternChange = false;
        connectorType = ConnectorSegmentType.Bezier;
    }
    /// <summary>
    /// This method is used to update the connector type as Straight.
    /// </summary>
    public async Task OnStraightChange(Microsoft.AspNetCore.Components.ChangeEventArgs args)
    {
        await OnUpdateConnectorType("Straight", args.Value.ToString());
        PatternChange = false;
        connectorType = ConnectorSegmentType.Straight;
    }
    /// <summary>
    /// This method is used to update the connector type.
    /// </summary>
    public async Task OnUpdateConnectorType(string prop, string value)
    {
        SfDiagramComponent Diagram = Parent.DiagramContent.Diagram;
        Diagram.BeginUpdate();
        Diagram.StartGroupAction();
        if (!PreventPropertyChange)
        {
            switch (prop)
            {
                case "Bezier":
                    for (int i = 0; i < Parent.DiagramContent.Diagram.Connectors.Count; i++)
                    {
                        Connector connector = Parent.DiagramContent.Diagram.Connectors[i];
                        connector.Type = ConnectorSegmentType.Bezier;
                    }
                    break;
                case "Straight":
                    for (int j = 0; j < Parent.DiagramContent.Diagram.Connectors.Count; j++)
                    {
                        Connector connector = Parent.DiagramContent.Diagram.Connectors[j];
                        connector.Type = ConnectorSegmentType.Straight;
                    }
                    break;
            }
        }
        Diagram.EndGroupAction();
        await Diagram.EndUpdateAsync();
    }
    #endregion
    /// <summary>
    /// This method is used to update Mindmap properties
    /// </summary>
    #region
    public void OnMindMapLevelChange(Syncfusion.Blazor.DropDowns.ChangeEventArgs<string, DefaultDropDownField> args)
    {
        mindMapLevel = args.Value;
        LevelType = args.Value;
        bool PreventBindingPropertyChange = false;
        if (Parent.DiagramContent.Diagram.SelectionSettings.Nodes.Count > 0)
        {
            var node = Parent.DiagramContent.Diagram.SelectionSettings.Nodes[0];
            if (node.AdditionalInfo != null && node.AdditionalInfo.Count > 0)
            {
                var obj = System.Text.Json.JsonSerializer.Serialize(node.AdditionalInfo);
                NodeAddInfo NodeInfo = JsonSerializer.Deserialize<NodeAddInfo>(obj.ToString());
                if ("Level" + NodeInfo.Level.ToString() == mindMapLevel || NodeInfo.Level.ToString() == mindMapLevel)
                {
                    PreventBindingPropertyChange = true;
                }
            }
        }
        if (!PreventBindingPropertyChange)
            bindMindMapProperties(GetNodeForPropertyChange());
    }
    /// <summary>
    /// This method is used to get node for property change.
    /// </summary>
    private Node GetNodeForPropertyChange(string? levelType = null)
    {
        ObservableCollection<Node> Nodes = null;
        if (levelType == null)
        {
            Nodes = LevelType == "Selected Item" ? Parent.DiagramContent.Diagram.SelectionSettings.Nodes : Parent.DiagramContent.Diagram.Nodes;
        }
        else
            Nodes = Parent.DiagramContent.Diagram.Nodes;
        if (Nodes.Count > 0)
        {
            Node node;
            for (int i = 0; i < Nodes.Count; i++)
            {
                node = Parent.DiagramContent.Diagram.GetObject(Nodes[i].ID) as Node;
                if (node.AdditionalInfo != null && node.AdditionalInfo.Count > 0)
                {
                    var obj = System.Text.Json.JsonSerializer.Serialize(node.AdditionalInfo);
                    NodeAddInfo NodeInfo = JsonSerializer.Deserialize<NodeAddInfo>(obj.ToString());
                    if (levelType != null)
                    {
                        if ("Level" + NodeInfo.Level.ToString() == levelType || NodeInfo.Level.ToString() == levelType)
                        {
                            return node;
                        }
                    }
                    else if ("Level" + NodeInfo.Level.ToString() == mindMapLevel || NodeInfo.Level.ToString() == mindMapLevel || LevelType == "Selected Item")
                    {
                        return node;
                    }
                }
            }
        }
        return Parent.DiagramContent.Diagram.Nodes[0];
    }
    /// <summary>
    /// This method is used to update the shape for nodes.
    /// </summary>
    public void OnMindMapShapeChange(Syncfusion.Blazor.DropDowns.ChangeEventArgs<string, MindMapShapes> args)
    {
        if (args.IsInteracted)
        {
            mindMapShapeValue = args.Value;
            UpdateMindMapProperties("Shape", args.Value);
            PatternChange = false;
        }
    }
    /// <summary>
    /// This method is used to update the fill color for nodes.
    /// </summary>
    public void OnFillColorChange(ColorPickerEventArgs args)
    {
        UpdateMindMapProperties("Fill", (args.CurrentValue).Hex);
    }
    /// <summary>
    /// This method is used to update the stroke color for nodes.
    /// </summary>
    public void OnStrokeColorChange(ColorPickerEventArgs args)
    {
        UpdateMindMapProperties("StrokeColor", (args.CurrentValue).Hex);
    }
    /// <summary>
    /// This method is used to update the stroke dash array for nodes.
    /// </summary>
    public void OnStrokeDashArrayChange(Syncfusion.Blazor.DropDowns.ChangeEventArgs<string, BorderStylesFields> args)
    {
        UpdateMindMapProperties("StrokeDashArray", args.Value == "None" ? "" : args.Value);
    }
    /// <summary>
    /// This method is used to update the opacity for nodes.
    /// </summary>
    public void OnMindMapOpacityChange(double Value)
    {
        UpdateMindMapProperties("Opacity", (Value / 100).ToString());
    }
    /// <summary>
    /// This method is used to update the stroke width for nodes.
    /// </summary>
    public void OnStrokeWidthChange(Syncfusion.Blazor.Inputs.ChangeEventArgs<double> args)
    {
        UpdateMindMapProperties("StrokeWidth", args.Value.ToString());
    }
    /// <summary>
    /// This method is used to update the font family for annotations.
    /// </summary>
    public void OnFontFamilyChange(Syncfusion.Blazor.DropDowns.ChangeEventArgs<string, FontFamilyListFields> args)
    {
        UpdateMindMapProperties("FontFamily", args.Value);
    }
    /// <summary>
    /// This method is used to update the font size for annotations.
    /// </summary>
    public void OnTextFontSizeChanged(Syncfusion.Blazor.Inputs.ChangeEventArgs<double> args)
    {
        UpdateMindMapProperties("FontSize", args.Value.ToString());
    }
    /// <summary>
    /// This method is used to update the text position for annotations.
    /// </summary>
    public void OnTextPositionChange(Syncfusion.Blazor.DropDowns.ChangeEventArgs<string, string> args)
    {
        UpdateMindMapProperties("TextPosition", args.Value);
    }
    /// <summary>
    /// This method is used to update the text color for annotations.
    /// </summary>
    public void OnTextColorChange(ColorPickerEventArgs args)
    {
        UpdateMindMapProperties("FontColor", (args.CurrentValue).Hex);
    }
    /// <summary>
    /// This method is used to update the opacity for annotations.
    /// </summary>
    public void OnTextOpacityChange(double Value)
    {
        UpdateMindMapProperties("TextOpacity", (Value / 100).ToString());
    }
    /// <summary>
    /// This method is used to update the horizontal spacing for layout.
    /// </summary>
    private async Task OnHorizontalSpaceChange(Syncfusion.Blazor.Inputs.ChangeEventArgs<int?> args)
    {
        horizontalValue = (int)args.Value;
        await Parent.DiagramContent.UpdateSpacing((int)horizontalValue, "Horizontal");
    }
    /// <summary>
    /// This method is used to update the vertical spacing for layout.
    /// </summary>
    private async Task OnVerticalSpaceChange(Syncfusion.Blazor.Inputs.ChangeEventArgs<int?> args)
    {
        verticalValue = (int)args.Value;
        await Parent.DiagramContent.UpdateSpacing((int)verticalValue, "Vertical");
    }
    /// <summary>
    /// This method is used to update the text style for annotations.
    /// </summary>
    private void OnTextStyleClick(Syncfusion.Blazor.Navigations.ClickEventArgs args)
    {
        string commandType = args.Item.TooltipText;

        switch (commandType)
        {
            case "Bold":
                BoldCss = (!BoldCss.Contains(" tb-item-selected")) ? BoldCss + " tb-item-selected" : BoldCss.Replace(" tb-item-selected", "");
                break;
            case "Italic":
                ItalicCss = (!ItalicCss.Contains(" tb-item-selected")) ? ItalicCss + " tb-item-selected" : ItalicCss.Replace(" tb-item-selected", "");
                break;
            case "Underline":
                UnderlineCss = (!UnderlineCss.Contains(" tb-item-selected")) ? UnderlineCss + " tb-item-selected" : UnderlineCss.Replace(" tb-item-selected", "");
                break;
        }
        UpdateMindMapProperties(commandType, "true");
        StateHasChanged();
    }
    /// <summary>
    /// This method is used to update the stroke style for annotations.
    /// </summary>
    private void UpdateStrokeStyleValue(string strokeVal)
    {
        switch (strokeVal)
        {
            case "1,2":
                strokeDashArrayValue = "1,2";
                strokeStyleValue = 1;
                break;
            case "3,3":
                strokeDashArrayValue = "3,3";
                strokeStyleValue = 2;
                break;
            case "5,3":
                strokeDashArrayValue = "5,3";
                strokeStyleValue = 3;
                break;
            case "4,4,1":
                strokeDashArrayValue = "4,4,1";
                strokeStyleValue = 4;
                break;
            default:
                strokeDashArrayValue = "";
                strokeStyleValue = 0;
                break;
        }
    }
    /// <summary>
    /// Represents an item in a node information
    /// </summary>
    public class NodeAddInfo
    {
        public string Level { get; set; }
        public string Orientation { get; set; }
    }
    /// <summary>
    /// This method is used to update the mindmap properties
    /// </summary>
    public void UpdateMindMapProperties(string prop, string Value)
    {
        if (!PreventPropertyChange)
        {
            ObservableCollection<Node> Nodes = LevelType == "Selected Item" ? Parent.DiagramContent.Diagram.SelectionSettings.Nodes : Parent.DiagramContent.Diagram.Nodes;
            if (Nodes.Count > 0)
            {
                if (Value != null)
                {
                    Parent.DiagramContent.Diagram.StartGroupAction();
                    Node node;
                    for (int i = 0; i < Nodes.Count; i++)
                    {
                        node = Parent.DiagramContent.Diagram.GetObject(Nodes[i].ID) as Node;
                        if (node.AdditionalInfo != null && node.AdditionalInfo.Count > 0)
                        {
                            var obj = System.Text.Json.JsonSerializer.Serialize(node.AdditionalInfo);
                            NodeAddInfo NodeInfo = System.Text.Json.JsonSerializer.Deserialize<NodeAddInfo>(obj.ToString());
                            if ("Level" + NodeInfo.Level.ToString() == mindMapLevel || NodeInfo.Level.ToString() == mindMapLevel || LevelType == "Selected Item")
                            {
                                switch (prop)
                                {
                                    case "Fill":
                                        node.Style.Fill = Value;
                                        break;
                                    case "StrokeColor":
                                        node.Style.StrokeColor = Value;
                                        List<string> Connectors = node.InEdges;
                                        OnUpdateConnectorProperties(Connectors, Value, "StrokeColor");
                                        break;
                                    case "StrokeDashArray":
                                        node.Style.StrokeDashArray = Value;
                                        UpdateStrokeStyleValue(Value);
                                        List<string> InEdges = node.InEdges;
                                        OnUpdateConnectorProperties(InEdges, Value, "StrokeDashArray");
                                        break;
                                    case "StrokeWidth":
                                        node.Style.StrokeWidth = Double.Parse(Value);
                                        break;
                                    case "Opacity":
                                        node.Style.Opacity = Double.Parse(Value);
                                        break;
                                    case "Shape":
                                        UpdateShape(Value, node);
                                        break;
                                }
                                if (node.Annotations.Count > 0)
                                {
                                    ShapeAnnotation Annotation = node.Annotations[0];
                                    switch (prop)
                                    {
                                        case "FontFamily":
                                            Annotation.Style.FontFamily = Value;
                                            break;
                                        case "FontSize":
                                            Annotation.Style.FontSize = Int32.Parse(Value);
                                            break;
                                        case "FontColor":
                                            Annotation.Style.Color = Value;
                                            break;
                                        case "TextOpacity":
                                            Annotation.Style.Opacity = Double.Parse(Value);
                                            break;
                                        case "Bold":
                                            Annotation.Style.Bold = !Annotation.Style.Bold;
                                            break;
                                        case "Italic":
                                            Annotation.Style.Italic = !Annotation.Style.Italic;
                                            break;
                                        case "Underline":
                                            Annotation.Style.TextDecoration = (Annotation.Style.TextDecoration == TextDecoration.Underline) ? TextDecoration.None : TextDecoration.Underline;
                                            break;
                                    }
                                }
                            }
                        }
                    }
                    if (prop != "Opacity")
                    {
                        slider();
                        sliderText();
                    }
                    Parent.DiagramContent.Diagram.EndGroupAction();
                }
            }
        }
    }
    /// <summary>
    /// This method is used to update the Node's shape
    /// </summary>

    private void UpdateShape(string Value, Node Element)
    {
        if (Value == "Rectangle")
        {
            Element.Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle };
            (Element.Shape as BasicShape).CornerRadius = Element.ID == "rootNode" ? 5 : 0;
        }
        else if (Value == "Ellipse")
            Element.Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Ellipse };
        else if (Value == "Star")
            Element.Shape = new PathShape() { Type = NodeShapes.Path, Data = "M28 1.60745L32.6757 7.49196L33.1063 8.03386L33.7651 7.82174L43.5571 4.66902L41.3666 9.9757L40.8265 11.2839L42.24 11.356L52.0141 11.8539L45.233 15.0979L43.3473 16L45.233 16.9021L52.0141 20.1461L42.24 20.644L40.8265 20.716L41.3666 22.0243L43.5571 27.331L33.7651 24.1783L33.1063 23.9661L32.6757 24.508L28 30.3926L23.3243 24.508L22.8937 23.9661L22.2349 24.1783L12.4429 27.331L14.6334 22.0243L15.1734 20.7161L13.7599 20.644L3.98585 20.1461L10.767 16.9021L12.6527 16L10.767 15.0979L3.98585 11.8539L13.7599 11.356L15.1734 11.2839L14.6334 9.9757L12.4429 4.66902L22.2349 7.82174L22.8937 8.03386L23.3243 7.49196L28 1.60745Z" };
        else if (Value == "Cloud")
            Element.Shape = new PathShape() { Type = NodeShapes.Path, Data = "M55.7315 17.239C57.8719 21.76 54.6613 27.788 47.1698 26.0787C46.0997 32.309 33.2572 35.323 28.9764 29.2951C25.7658 35.323 10.7829 33.816 10.7829 26.0787C3.29143 30.802 -0.989391 20.253 2.22121 17.239C-0.989317 14.2249 2.22121 6.68993 10.7829 8.39934C13.9935 -0.845086 25.7658 -0.845086 28.9764 5.18301C32.187 0.661909 45.0294 0.661908 47.1698 8.39934C52.5209 5.18301 60.0123 12.7179 55.7315 17.239Z" };
        else
            Element.Shape = new PathShape() { Type = NodeShapes.Path, Data = "M24.9123 3.78029C25.0975 4.3866 24.9466 4.88753 24.8501 5.15598L24.8444 5.17188L24.8379 5.18757C24.543 5.89091 23.7879 6.37572 22.9737 6.71397C22.1386 7.06093 21.0847 7.3197 19.9302 7.51132C17.6145 7.89568 14.7099 8.03929 11.8845 7.99097C9.05877 7.94266 6.24887 7.70127 4.11982 7.29202C3.06318 7.08891 2.11594 6.83369 1.41022 6.51281C0.766274 6.22 0 5.72087 0 4.9469C0 4.01004 0.964525 3.41277 1.79867 3.05724C2.70576 2.67063 3.89493 2.37901 5.11258 2.15935C7.44304 1.73893 10.1147 1.54134 11.7304 1.52346C11.8769 1.52184 12.0122 1.59735 12.0902 1.72133V1.72133C12.2554 1.98406 12.0895 2.33011 11.7819 2.37125C6.76467 3.04222 7.47107 3.02672 5.26455 3.42478C4.10916 3.63321 3.07622 3.89464 2.39298 4.18584C1.76916 4.45172 1.91438 4.9469 1.92108 4.92166C1.95272 4.95811 2.05541 5.05272 2.36059 5.19149C2.83828 5.4087 3.58481 5.6232 4.56968 5.81251C6.52366 6.18811 9.1877 6.42238 11.9256 6.4692C14.6639 6.51602 17.4127 6.37423 19.539 6.02131C20.6055 5.8443 21.4697 5.62145 22.0872 5.36491C22.7085 5.10676 22.9449 4.87196 23.0162 4.71867C23.0759 4.54803 23.1185 4.35742 23.052 4.13951C22.9867 3.92586 22.7842 3.58431 22.1006 3.17831C20.6845 2.3372 17.4158 1.34558 10.1686 0.773902C10.0395 0.763721 9.92243 0.68718 9.86361 0.571853V0.571853C9.7338 0.317364 9.92861 0.0177825 10.2139 0.0325302C17.4619 0.407187 21.4191 0.873597 23.2463 1.95885C24.2179 2.53589 24.7233 3.16153 24.9123 3.78029Z" };
    }
    /// <summary>
    /// This method is used to update the  connector properties
    /// </summary>
    public void OnUpdateConnectorProperties(List<string> Connectors, string Value, string Property)
    {
        IDiagramObject Connector;
        Parent.DiagramContent.Diagram.StartGroupAction();
        for (int i = 0; i < Connectors.Count; i++)
        {
            Connector = Parent.DiagramContent.Diagram.GetObject(Connectors[i]) as Connector;
            if (Connector != null)
            {
                if (Property == "StrokeColor")
                    (Connector as Connector).Style.StrokeColor = Value;
                else if (Property == "StrokeDashArray")
                {
                    (Connector as Connector).Style.StrokeDashArray = Value;
                    UpdateStrokeStyleValue(Value);
                }
            }
        }
        Parent.DiagramContent.Diagram.EndGroupAction();
    }
    #endregion
    /// <summary>
    /// This method is used to add a child to the selected node
    /// </summary>
    public async void AddNode(string orientation, string? label = "Node")
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        diagram.Constraints = DiagramConstraints.Default & ~DiagramConstraints.UndoRedo;
        if (diagram.SelectionSettings.Nodes.Count > 0)
        {
            Node SelectedNode = diagram.SelectionSettings.Nodes[0];

            if (SelectedNode.ID != "rootNode")
            {
                string selectedNodeOrientation = Convert.ToString(SelectedNode.AdditionalInfo["Orientation"]);
                orientation = selectedNodeOrientation;
            }
            Dictionary<string, object> MindMapData = new Dictionary<string, object>();
            diagram.BeginUpdate();
            MindMapData = GetMindMapShape(SelectedNode, label);
            Node node = MindMapData["Node"] as Node;
            AddMindMapLevels("Level" + Convert.ToString(node.AdditionalInfo["Level"]));
            node.ID = "node" + node.ID;
            if (node.AdditionalInfo != null)
                node.AdditionalInfo["Orientation"] = orientation;
            else
                node.AdditionalInfo.Add("Orientation", orientation);
            Connector connector = SetConnectorDefault(diagram, orientation, (MindMapData["Connector"] as Connector), SelectedNode.ID, node.ID);
            await diagram.AddDiagramElementsAsync(new DiagramObjectCollection<NodeBase>() { node, connector });
            if (PatternChange)
                await MindmapPatternChange(PatternValue);
            Node node1 = diagram.GetObject(node.ID) as Node;
            await diagram.DoLayoutAsync();
            await diagram.EndUpdateAsync();
            DiagramRect bound = new DiagramRect((node1.OffsetX - (node1.Width / 2)), node1.OffsetY - (node1.Height / 2), node1.Width, node1.Height);
            diagram.BeginUpdate();
            diagram.Select(new ObservableCollection<IDiagramObject>() { node1 });
            diagram.StartTextEdit(node1);
            await diagram.EndUpdateAsync();
            diagram.Constraints = DiagramConstraints.Default;
            for (int i = 0; i < Parent.DiagramContent.TreeViewNodes.Count; i++)
            {
                if (SelectedNode.ID == Parent.DiagramContent.TreeViewNodes[i].Id)
                {
                    List<TreeItem> album = new List<TreeItem>();
                    TreeItem Addednode = new TreeItem();
                    Addednode.Id = node.ID;
                    Addednode.Name = label != "" ? label : "Node";
                    Addednode.ParentId = Parent.DiagramContent.TreeViewNodes[i].Id;
                    album.Add(Addednode);
                    Parent.DiagramContent.Dom.AddNodes(album);
                    Parent.DiagramContent.TreeViewNodes.Add(Addednode);
                    for (int j = 0; j < Parent.DiagramContent.TreeViewNodes.Count; j++)
                    {
                        if (Parent.DiagramContent.TreeViewNodes[i].Id == Parent.DiagramContent.TreeViewNodes[j].Id)
                        {
                            Parent.DiagramContent.TreeViewNodes[j].HasChild = true;
                            Parent.DiagramContent.TreeViewNodes[j].Expanded = true;
                            List<string> array = new List<string>();
                            String[] emptystring;
                            array.Add( Parent.DiagramContent.TreeViewNodes[j].Id.ToString());
                            emptystring = array.ToArray();
                            await Parent.DiagramContent.Dom.ExpandAllAsync(emptystring);
                        }

                    }

                }
            }

        }
    }
    /// <summary>
    /// This method is used to update the added node's shape and style properties
    /// </summary>
    public Dictionary<string, object> GetMindMapShape(Node ParentNode, string? Label = "Node")
    {
        Dictionary<string, object> items = new Dictionary<string, object>();
        Node childNode;
        Connector childConnector = new Connector();
        Dictionary<string, object> addInfo = ParentNode.AdditionalInfo;
        string newLevel = Convert.ToString(addInfo["Level"]);
        int levelValue = int.Parse(newLevel);

        Dictionary<string, object> ChildInfo = new Dictionary<string, object>();
        ChildInfo.Add("Level", (levelValue + 1).ToString());
        childNode = new Node()
            {
                Width = 100,
                Height = 30,
                Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle },
                Annotations = new DiagramObjectCollection<ShapeAnnotation>() { new ShapeAnnotation() { Content = Label } },
                Style = new ShapeStyle() { Fill = "#000000", StrokeColor = "#000000" },
                AdditionalInfo = ChildInfo
            };
        childConnector = new Connector()
            {
                Type = ConnectorSegmentType.Bezier,
                Style = new ShapeStyle() { StrokeWidth = 3 },
            };
        if (levelValue < 1)
        {
            childNode.Style.Fill = fillColorCode[lastFillIndex];
            childNode.Style.StrokeColor = borderColorCode[lastFillIndex];
            childNode.Style.StrokeWidth = 2;
            if (lastFillIndex + 1 >= fillColorCode.Length)
                this.lastFillIndex = 0;
            else
                lastFillIndex++;
        }
        else
            childNode.Style.StrokeColor = childNode.Style.Fill = ParentNode.Style.Fill;
        childConnector.Style.StrokeColor = childNode.Style.Fill;
        childConnector.TargetDecorator = new DecoratorSettings() { Shape = DecoratorShape.None };
        childConnector.Constraints = ConnectorConstraints.Select | ConnectorConstraints.PointerEvents | ConnectorConstraints.Delete;
        childNode.Ports = new DiagramObjectCollection<PointPort>()
        {
            new PointPort() { ID = "leftPort", Offset = new DiagramPoint() { X= 0, Y=0.5}},
            new PointPort() { ID = "rightPort", Offset = new DiagramPoint() { X= 1, Y=0.5}},
        };
        Node sameLevelNode = GetNodeForPropertyChange("Level" + (levelValue + 1));
        if (sameLevelNode != null && ParentNode.ID != sameLevelNode.ID)
        {
            childNode.Shape = sameLevelNode.Shape.Clone() as Shape;
        }
        items.Add("Node", childNode);
        items.Add("Connector", childConnector);
        return items;
    }
    /// <summary>
    /// This method is used to get the branch type of the nodes
    /// </summary>
    public BranchType GetBranchType(IDiagramObject obj)
    {
        string type = Convert.ToString((obj as Node).AdditionalInfo["Orientation"]);
        BranchType Branch = BranchType.Root;
        if (type == "Left")
            Branch = BranchType.Left;
        else if (type == "Right")
            Branch = BranchType.Right;
        else if (type == "Center")
            Branch = BranchType.Root;
        return Branch;
    }
    /// <summary>
    /// This method is used to add the new midmap level in the level dropdown datasource
    /// </summary>
    public void AddMindMapLevels(string Level)
    {
        List<DefaultDropDownField> dropdowndatasource = MindMapLevels;
        DefaultDropDownField lastItem = dropdowndatasource[dropdowndatasource.Count - 1];
        dropdowndatasource.RemoveAt(dropdowndatasource.Count - 1);
        bool isExist = false;
        for (int i = 0; i < dropdowndatasource.Count; i++)
        {
            DefaultDropDownField data = dropdowndatasource[i];
            if (data.Text == Level)
            {
                isExist = true;
            }
        }
        if (!isExist)
        {
            DefaultDropDownField newData = new DefaultDropDownField() { Text = Level, Value = Level };
            dropdowndatasource.Add(newData);
        }
        dropdowndatasource.Add(lastItem);
        MindMapLevels = dropdowndatasource;
        StateHasChanged();
    }
    /// <summary>
    /// This method is used to update the defalut vale for the newly added connectors
    /// </summary>
    public Connector SetConnectorDefault(SfDiagramComponent diagram, string orientation, Connector connector, string sourceID, string targetID)
    {
        connector.ID = "connector" + connector.ID;
        connector.SourceID = sourceID;
        connector.TargetID = targetID;
        connector.SourcePortID = "right";
        connector.TargetPortID = "left";
        if (orientation == "Right")
        {
            connector.SourcePortID = "left";
            connector.TargetPortID = "right";
        }
        connector.Style.StrokeWidth = 2;
        connector.Type = connectorType;
        return connector;
    }
    /// <summary>
    /// This method is used to add the sibling nodetor the selected node
    /// </summary>
    public async void AddSiblingChild(string orientation)
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        diagram.Constraints = DiagramConstraints.Default & ~DiagramConstraints.UndoRedo;
        if (diagram.SelectionSettings.Nodes.Count > 0)
        {
            Node SelectedNode = diagram.SelectionSettings.Nodes[0];
            if (SelectedNode.ID != "rootNode")
            {
                string selectedNodeOrientation = Convert.ToString(SelectedNode.AdditionalInfo["Orientation"]);
                orientation = selectedNodeOrientation;
            }
            Connector childConnector = GetConnector(diagram.Connectors, SelectedNode.InEdges[0]);
            Dictionary<string, object> MindMapData = new Dictionary<string, object>();
            diagram.BeginUpdate();
            MindMapData = GetMindMapShape(GetNode(diagram.Nodes, childConnector.SourceID));
            Node node = MindMapData["Node"] as Node;
            node.ID = "node" + node.ID;
            if (node.AdditionalInfo != null)
                node.AdditionalInfo["Orientation"] = orientation;
            else
                node.AdditionalInfo.Add("Orientation", orientation);
            Connector connector = SetConnectorDefault(diagram, orientation, (MindMapData["Connector"] as Connector), childConnector.SourceID, node.ID);
            await diagram.AddDiagramElementsAsync(new DiagramObjectCollection<NodeBase>() { node, connector });
            if (PatternChange)
                MindmapPatternChange(PatternValue);
            Node node1 = GetNode(diagram.Nodes, node.ID);
            for (int i = 0; i < Parent.DiagramContent.TreeViewNodes.Count; i++)
            {
                if (SelectedNode.ID == Parent.DiagramContent.TreeViewNodes[i].Id)
                {
                    List<TreeItem> album = new List<TreeItem>();
                    TreeItem Addednode = new TreeItem();
                    Addednode.Id = node.ID;
                    Addednode.Name = "Node";
                    Addednode.Expanded=true;
                    Addednode.ParentId = Parent.DiagramContent.TreeViewNodes[i].ParentId;
                    album.Add(Addednode);
                    Parent.DiagramContent.Dom.AddNodes(album);
                    Parent.DiagramContent.TreeViewNodes.Add(Addednode);
                }
            }
            await diagram.DoLayoutAsync();
            await diagram.EndUpdateAsync();
            diagram.BeginUpdate();
            diagram.Select(new ObservableCollection<IDiagramObject>() { node1 });
            diagram.StartTextEdit(node1);
            await diagram.EndUpdateAsync();
            diagram.Constraints = DiagramConstraints.Default;

        }
    }
    /// <summary>
    /// This method is used to get the connectors by node's inedges and outedges
    /// </summary>
    public Connector GetConnector(DiagramObjectCollection<Connector> diagramConnectors, string name)
    {
        for (int i = 0; i < diagramConnectors.Count; i++)
        {
            if (diagramConnectors[i].ID == name)
            {
                return diagramConnectors[i];
            }
        }
        return null;
    }
    /// <summary>
    /// This method is used to get the Nodes by connectors sourceID and targetID.
    /// </summary>
    public Node GetNode(DiagramObjectCollection<Node> diagramNodes, string name)
    {
        for (int i = 0; i < diagramNodes.Count; i++)
        {
            if (diagramNodes[i].ID == name)
            {
                return diagramNodes[i];
            }
        }
        return null;
    }
    /// <summary>
    /// This method is used to remove the selected node from the layout.
    /// </summary>
    public async void RemoveChild()
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        if (diagram.SelectionSettings.Nodes.Count > 0)
        {
            diagram.BeginUpdate();
            RemoveSubChild(diagram.SelectionSettings.Nodes[0], diagram);
            await diagram.EndUpdateAsync();
            await diagram.DoLayoutAsync();
        }
    }
    /// <summary>
    /// This method is used to remove selected node's children from the layout.
    /// </summary>
    public void RemoveSubChild(Node node, SfDiagramComponent diagram)
    {
        diagram.Constraints = DiagramConstraints.Default & ~DiagramConstraints.UndoRedo;
        for (int i = 0; i < Parent.DiagramContent.TreeViewNodes.Count; i++)
        {
            if (diagram.SelectionSettings.Nodes[0].ID == Parent.DiagramContent.TreeViewNodes[i].Id)
            {
                List<string> array = new List<string>();
                String[] emptystring;
                string id = Parent.DiagramContent.TreeViewNodes[i].ParentId;
                array.Add(Parent.DiagramContent.TreeViewNodes[i].Id.ToString());
                Parent.DiagramContent.TreeViewNodes.Remove(Parent.DiagramContent.TreeViewNodes[i]);
                emptystring = array.ToArray();
                Parent.DiagramContent.Dom.RemoveNodes(emptystring);
                for (int j = 0; j < Parent.DiagramContent.TreeViewNodes.Count; j++)
                {
                    if (id == Parent.DiagramContent.TreeViewNodes[j].Id)
                    {
                        for (int k = 0; k < Parent.DiagramContent.TreeViewNodes.Count; k++)
                        {
                            Parent.DiagramContent.TreeViewNodes[j].HasChild = false;
                            if (Parent.DiagramContent.TreeViewNodes[j].Id == Parent.DiagramContent.TreeViewNodes[k].ParentId)
                            {
                                Parent.DiagramContent.TreeViewNodes[j].HasChild = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        for (int i = node.OutEdges.Count - 1; i >= 0; i--)
        {
            Connector connector = GetConnector(diagram.Connectors, node.OutEdges[i]);
            Node childNode = GetNode(diagram.Nodes, connector.TargetID);
            if (childNode != null && childNode.OutEdges.Count > 0)
                RemoveSubChild(childNode, diagram);
            else
                diagram.Nodes.Remove(childNode);
        }
        for (int j = node.InEdges.Count - 1; j >= 0; j--)
        {
            Connector connector = GetConnector(diagram.Connectors, node.InEdges[j]);
            Node childNode = GetNode(diagram.Nodes, connector.SourceID);
            var index = childNode.OutEdges.IndexOf(connector.ID);
            if (childNode.OutEdges.Count > 1 && index == 0)
                index = childNode.OutEdges.Count;
            if (index > 0)
            {
                var node1 = childNode.OutEdges[index - 1];
                Connector connector1 = diagram.GetObject(node1) as Connector;
                Node node2 = GetNode(diagram.Nodes, connector1.TargetID);
                diagram.Select(new ObservableCollection<IDiagramObject>() { node2 });
            }
            else
                diagram.Select(new ObservableCollection<IDiagramObject>() { childNode });
        }
        if (node.ID != "rootNode")
            diagram.Nodes.Remove(node);
        diagram.Constraints = DiagramConstraints.Default;
    }
    /// <summary>
    /// This method is used to edit the node's label.
    /// </summary>
    public async Task EditNode()
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        diagram.BeginUpdate();
        if (diagram.SelectionSettings.Nodes.Count > 0)
        {
            Node node = diagram.SelectionSettings.Nodes[0];
            diagram.StartTextEdit(node);
        }
        await diagram.EndUpdateAsync();
    }
    /// <summary>
    /// This method is used to update the selected node's text in bold in style
    /// </summary>
    public void TextBold()
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        if (diagram.SelectionSettings.Nodes.Count > 0)
        {
            Node node = diagram.SelectionSettings.Nodes[0];
            if (node.Annotations.Count > 0)
                node.Annotations[0].Style.Bold = true;
        }
        if (!BoldCss.Contains("tb-item-selected"))
        {
            BoldCss += " tb-item-selected";
            StateHasChanged();
        }
    }
    /// <summary>
    /// This method is used to update the selected node's text in italic in style
    /// </summary>
    public void TextItalic()
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        if (diagram.SelectionSettings.Nodes.Count > 0)
        {
            Node node = diagram.SelectionSettings.Nodes[0];
            if (node.Annotations.Count > 0)
                node.Annotations[0].Style.Italic = true;
        }
        if (!ItalicCss.Contains("tb-item-selected"))
        {
            ItalicCss += " tb-item-selected";
            StateHasChanged();
        }
    }
    /// <summary>
    /// This method is used to update the selected node's text in underline in style
    /// </summary>
    public void TextUnderline()
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        if (diagram.SelectionSettings.Nodes.Count > 0)
        {
            Node node = diagram.SelectionSettings.Nodes[0];
            if (node.Annotations.Count > 0)
                node.Annotations[0].Style.TextDecoration = TextDecoration.Underline;
        }
        if (!UnderlineCss.Contains("tb-item-selected"))
        {
            UnderlineCss += " tb-item-selected";
            StateHasChanged();
        }
    }
    /// <summary>
    /// This method is used to update the diagram in fitToPage
    /// </summary>
    public void FitPage()
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        FitOptions fitoption = new FitOptions()
            {
                Mode = FitMode.Both,
                Region = DiagramRegion.PageSettings,
            };
        Parent.DiagramContent.Diagram.FitToPage(fitoption);
    }
    /// <summary>
    /// This method is used to hide the quick commands
    /// </summary>
    public void OnHideNodeClick()
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        Node node = GetNode(diagram.Nodes, "textNode");
        node.IsVisible = !node.IsVisible;
    }
    /// <summary>
    /// This method is used to copy the element with its children
    /// </summary>
    public void CopyLayout()
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        if (diagram.SelectionSettings.Nodes.Count > 0)
        {
            Node selectedNode = diagram.SelectionSettings.Nodes[0];
            if (selectedNode.ID != "rootNode")
                pasteData = CloneSelectedItemswithChildElements();
            else if(selectedNode.ID.Contains("rootNode"))
            {
                diagram.Copy();
            }
        }
    }
    private DiagramObjectCollection<NodeBase> CloneSelectedItemswithChildElements()
    {
        return CloneChild();
    }
    /// <summary>
    /// This method is used to clone the selected node
    /// </summary>
    private DiagramObjectCollection<NodeBase> CloneChild()
    {
        DiagramObjectCollection<NodeBase> selectedItems1 = new DiagramObjectCollection<NodeBase>();
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        if (diagram.SelectionSettings.Nodes.Count > 0)
        {
            Node node = diagram.SelectionSettings.Nodes[0];
            if (node.AdditionalInfo != null)
                node.AdditionalInfo["IsFirstNode"] = true;
            else
                node.AdditionalInfo.Add("IsFirstNode", true);
            selectedItems1.Add(node);
            selectedItems1 = CloneSubChildSubChild(node, selectedItems1);
        }
        return selectedItems1;
    }
    /// <summary>
    /// This method is used to clone the selected node's children
    /// </summary>
    private DiagramObjectCollection<NodeBase> CloneSubChildSubChild(Node node, DiagramObjectCollection<NodeBase> select)
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        DiagramObjectCollection<NodeBase> select1 = new DiagramObjectCollection<NodeBase>();
        select1 = select;
        for (int i = node.OutEdges.Count - 1; i >= 0; i--)
        {
            Connector connector = diagram.GetObject(node.OutEdges[i]) as Connector;
            Node childNode = diagram.GetObject(connector.TargetID) as Node;
            select1.Add(connector);
            select1.Add(childNode);
            if (childNode.OutEdges.Count > 0)
            {
                CloneSubChildSubChild(childNode, select1);
            }
        }
        return SortCollection(select1);
    }
    /// <summary>
    /// This method is used to sort the nodes and connectors
    /// </summary>
    private DiagramObjectCollection<NodeBase> SortCollection(DiagramObjectCollection<NodeBase> select1)
    {
        DiagramObjectCollection<NodeBase> select = new DiagramObjectCollection<NodeBase>();
        for (int i = select1.Count - 1; i >= 0; i--)
        {
            if (select1[i] is Node)
                select.Add(select1[i]);
        }
        for (int j = select1.Count - 1; j >= 0; j--)
        {
            if (select1[j] is Connector)
                select.Add(select1[j]);
        }
        return select;
    }
    /// <summary>
    /// This method is used to cut the element with its children
    /// </summary>
    public async Task CutLayout()
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        if (diagram.SelectionSettings.Nodes.Count > 0)
        {
            CopyLayout();
            RemoveChild();
            await diagram.DoLayoutAsync();
        }
    }
    /// <summary>
    /// This method is used to paste the copied elements in the layout
    /// </summary>
    #region   
    public async Task PasteLayout()
    {
        IsCopyLayoutElement = true;
        await MindMapPaste();
        IsCopyLayoutElement = false;
        pasteData.Clear();
        PastedFirstItem = null;
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        if (diagram.SelectionSettings.Nodes.Count > 0)
        {
            Node selectedNode = diagram.SelectionSettings.Nodes[0];
            if (selectedNode.ID.Contains("rootNode"))
                diagram.Paste();
        }
    }
    /// <summary>
    /// This method is used to paste the copied elements in the layout.
    /// </summary>
    private async Task MindMapPaste()
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        Node selectedNode = diagram.SelectionSettings.Nodes[0];
        Node selectedelement = new Node();
        Dictionary<string, NodeBase> objectTable = new Dictionary<string, NodeBase>();
        Dictionary<string, string> keyTable = new Dictionary<string, string>();
        Dictionary<string, object> MindMapData = new Dictionary<string, object>();
        string selecteditemOrientation = string.Empty;
        if (pasteData.Count > 0)
        {
            diagram.BeginUpdate();
            diagram.StartGroupAction();
            DiagramObjectCollection<NodeBase> newElements = new DiagramObjectCollection<NodeBase>();
            foreach (NodeBase copy in pasteData)
            {
                objectTable[copy.ID] = copy;
            }
            for (int j = 0; j < pasteData.Count; j++)
            {
                NodeBase copy = pasteData[j];
                if (copy is Connector)
                    newElements = UpdateClonedConnector(copy as Connector, objectTable, keyTable, newElements);
                else
                    newElements = UpdateClonedNode(copy as Node, objectTable, keyTable, newElements);
            }
            await diagram.AddDiagramElementsAsync(newElements);
            if (selectedNode.ID != "rootNode")
                selecteditemOrientation = Convert.ToString(selectedNode.AdditionalInfo["Orientation"]);
            else
                selecteditemOrientation = Convert.ToString(PastedFirstItem.AdditionalInfo["Orientation"]);
            selectedelement = PastedFirstItem;
            MindMapData = GetMindMapShape(selectedNode);
            Connector connector = SetConnectorDefault(diagram, selecteditemOrientation, (MindMapData["Connector"] as Connector), selectedNode.ID, selectedelement.ID);
            await diagram.AddDiagramElementsAsync(new DiagramObjectCollection<NodeBase>() { connector });
            string newLevel = Convert.ToString(selectedNode.AdditionalInfo["Level"]);
            int selectedNodeLevel = 0;
            selectedNodeLevel = int.Parse(newLevel);
            UpdateLevel(selectedelement, selectedNodeLevel, selecteditemOrientation);
            await diagram.DoLayoutAsync();
            diagram.EndGroupAction();
            diagram.Select(new ObservableCollection<IDiagramObject>() { selectedelement });
            await diagram.EndUpdateAsync();
            Node viewNode = diagram.Nodes[diagram.Nodes.Count - 1];
            DiagramRect bound = new DiagramRect((viewNode.OffsetX - (viewNode.Width / 2)), viewNode.OffsetY - (viewNode.Height / 2), viewNode.Width, viewNode.Height);
            
        }
    }
    /// <summary>
    /// This method is used to return a cloned nodes
    /// </summary>
    private DiagramObjectCollection<NodeBase> UpdateClonedConnector(Connector copy, Dictionary<string, NodeBase> objectTable, Dictionary<string, string> keyTable, DiagramObjectCollection<NodeBase> newElements)
    {
        Connector clonedObj = copy.Clone() as Connector;
        clonedObj.ID = clonedObj.ID + Parent.DiagramContent.RandomId();
        newElements.Add(clonedObj);
        string nodeId = clonedObj.SourceID;
        clonedObj.SourceID = string.Empty;
        if (!string.IsNullOrEmpty(nodeId) && objectTable.ContainsKey(nodeId) && keyTable.ContainsKey(nodeId))
        {
            clonedObj.SourceID = keyTable[nodeId];
        }
        nodeId = clonedObj.TargetID;
        clonedObj.TargetID = string.Empty;
        if (!string.IsNullOrEmpty(nodeId) && objectTable.ContainsKey(nodeId) && keyTable.ContainsKey(nodeId))
        {
            clonedObj.TargetID = keyTable[nodeId];
        }
        return newElements;
    }
    /// <summary>
    /// This method is used to return a cloned connectors
    /// </summary>
    private DiagramObjectCollection<NodeBase> UpdateClonedNode(Node copy, Dictionary<string, NodeBase> objectTable, Dictionary<string, string> keyTable, DiagramObjectCollection<NodeBase> newElements)
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        Node newNode = copy.Clone() as Node;
        newNode.ID = newNode.ID + Parent.DiagramContent.RandomId();
        newElements.Add(newNode);
        newNode.ZIndex = -1;
        if (newNode != null) { keyTable[copy.ID] = newNode.ID; }
        return newElements;
    }
    /// <summary>
    /// This method is used to update the level of the elements that has to be pasted
    /// </summary>
    private void UpdateLevel(Node parentNode, int level, string orientation)
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        Node lastNode = parentNode;
        string level1 = string.Empty;
        int newLevel = level + 1;
        parentNode.AdditionalInfo["Level"] = newLevel.ToString();
        level1 = "Level" + parentNode.AdditionalInfo["Level"];
        AddMindMapLevels(level1);
        parentNode.AdditionalInfo["Orientation"] = orientation;
        for (int i = parentNode.OutEdges.Count - 1; i >= 0; i--)
        {
            Connector connector = GetConnector(diagram.Connectors, lastNode.OutEdges[i]);
            Node childNode = GetNode(diagram.Nodes, connector.TargetID);
            connector.SourcePortID = "right";
            connector.TargetPortID = "left";
            if (orientation == "Right")
            {
                connector.SourcePortID = "left";
                connector.TargetPortID = "right";
            }
            if (childNode.OutEdges.Count > 0)
            {
                string parentNodeLevel = Convert.ToString(parentNode.AdditionalInfo["Level"]);
                int nodeLevel = int.Parse(parentNodeLevel);
                UpdateLevel(childNode, nodeLevel, orientation);
            }
            else
            {
                string childLevel = Convert.ToString(parentNode.AdditionalInfo["Level"]);
                int childNewLevel = int.Parse(childLevel) + 1;
                childNode.AdditionalInfo["Level"] = childNewLevel;
                level1 = "Level" + childNode.AdditionalInfo["Level"];
                AddMindMapLevels(level1);
            }
        }
    }
    #endregion
    /// <summary>
    /// This method is used to navigate between the nodes
    /// </summary>
    public void NavigateChild(string direction)
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        Node? node = null;
        List<Node> sameLevelNodes = new List<Node>();
        if (direction == "Top" || direction == "Bottom")
        {
            sameLevelNodes = GetSameLevelNodes();
            int index = sameLevelNodes.IndexOf(diagram.SelectionSettings.Nodes[0]);
            node = direction == "Top" ? sameLevelNodes[index == 0 ? 0 : index - 1] : sameLevelNodes[index == (sameLevelNodes.Count-1) ? index :  index + 1];
        }
        else
            node = GetMinDistanceNode(diagram, direction);
        if (node != null)
        {
            diagram.Select(new ObservableCollection<IDiagramObject>() { node });
        }

    }
    /// <summary>
    /// This method is used to return a same level nodes
    /// </summary>

    private List<Node> GetSameLevelNodes()
    {
        List<Node> sameLevelNodes = new List<Node>();
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        if (diagram.SelectionSettings.Nodes.Count > 0)
        {
            Node node = diagram.SelectionSettings.Nodes[0];
            string orientation = Convert.ToString(node.AdditionalInfo["Orientation"]);
            Connector connector = GetConnector(diagram.Connectors, node.InEdges[0]);
            Node parentNode = GetNode(diagram.Nodes, connector.SourceID);
            for (int i = 0; i < parentNode.OutEdges.Count; i++)
            {
                connector = GetConnector(diagram.Connectors, parentNode.OutEdges[i]);
                Node childNode = GetNode(diagram.Nodes, connector.TargetID);
                if (childNode != null)
                {
                    string childOrientation = Convert.ToString(childNode.AdditionalInfo["Orientation"]);
                    if (orientation == childOrientation)
                    {
                        sameLevelNodes.Add(childNode);
                    }
                }
            }
        }
        return sameLevelNodes;
    }
    /// <summary>
    /// This method is used to return a minimum distance node whie navigating between left and right
    /// </summary>
    private Node GetMinDistanceNode(SfDiagramComponent diagram, string direction)
    {
        Node node = diagram.SelectionSettings.Nodes[0];
        double? nodeWidth = (node.Width == null) ? node.MinWidth : node.Width;
        DiagramRect parentBounds = new DiagramRect((node.OffsetX - (nodeWidth / 2)), node.OffsetY - (node.Height / 2), nodeWidth, node.Height);
        DiagramRect childBounds = new DiagramRect();
        double oldChildBoundsTop = 0;
        Node? childNode = null;
        Node? lastChildNode = null;
        Node? leftOrientationFirstChild = null;
        Node? rightOrientationFirstChild = null;
        if (node.ID == "rootNode")
        {
            List<string> edges = node.OutEdges;
            for (int i = 0; i < edges.Count; i++)
            {
                Connector connector = GetConnector(diagram.Connectors, edges[i]);
                childNode = GetNode(diagram.Nodes, connector.TargetID);
                if (Convert.ToString(childNode.AdditionalInfo["Orientation"]) == direction)
                {
                    if (direction == "Left" && leftOrientationFirstChild == null)
                        leftOrientationFirstChild = childNode;
                    if (direction == "Right" && rightOrientationFirstChild == null)
                        rightOrientationFirstChild = childNode;
                    double? childNodeWidth = (childNode.Width == null) ? childNode.MinWidth : childNode.Width;
                    childBounds = new DiagramRect((childNode.OffsetX - (childNodeWidth / 2)), childNode.OffsetY - (childNode.Height / 2), childNodeWidth, childNode.Height);
                    if (parentBounds.Top >= childBounds.Top && (childBounds.Top >= oldChildBoundsTop || oldChildBoundsTop == 0))
                    {
                        oldChildBoundsTop = childBounds.Top;
                        lastChildNode = childNode;
                    }
                }
            }
            if (lastChildNode != null)
                lastChildNode = direction == "Left" ? leftOrientationFirstChild : rightOrientationFirstChild;
        }
        else
        {
            List<string> edges = new List<string>();
            string selectType = string.Empty;
            string orientation = Convert.ToString(node.AdditionalInfo["Orientation"]);
            if (orientation == "Left")
            {
                edges = direction == "Left" ? node.OutEdges : node.InEdges;
                selectType = direction == "Left" ? "Target" : "Source";
            }
            else
            {
                edges = direction == "Right" ? node.OutEdges : node.InEdges;
                selectType = direction == "Right" ? "Target" : "Source";
            }
            for (int i = 0; i < edges.Count; i++)
            {
                Connector connector = GetConnector(diagram.Connectors, edges[i]);
                childNode = GetNode(diagram.Nodes, selectType == "Target" ? connector.TargetID : connector.SourceID);
                if (childNode.ID == "rootNode")
                    lastChildNode = childNode;
                else
                {
                    double? childNodeWidth = (childNode.Width == null) ? childNode.MinWidth : childNode.Width;
                    childBounds = new DiagramRect((childNode.OffsetX - (childNodeWidth / 2)), childNode.OffsetY - (childNode.Height / 2), childNodeWidth, childNode.Height);
                    if (selectType == "Target")
                    {
                        if (parentBounds.Top >= childBounds.Top && (childBounds.Top >= oldChildBoundsTop || oldChildBoundsTop == 0))
                        {
                            oldChildBoundsTop = childBounds.Top;
                            lastChildNode = childNode;
                        }
                    }
                    else
                        lastChildNode = childNode;
                }
            }
        }
        return lastChildNode;
    }
    /// <summary>
    /// This is used to drop the node on another and form layout
    /// </summary>
    public async void Drop(DropEventArgs args)
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        Node Element = (args.Element as DiagramSelectionSettings).Nodes[0] as Node;
        Node Target = args.Target as Node;
        bool isParent = false;
        List<string> edges = Element.OutEdges;
        if (edges != null && edges.Count > 0)
        {
            for (int i = 0; i < edges.Count; i++)
            {
                Connector connector = GetConnector(diagram.Connectors, edges[i]);
                Node childNode = GetNode(diagram.Nodes, connector.TargetID);
                if (Target.ID == childNode.ID)
                    isParent = true;
            }
        }
        if (!isParent)
        {
            Connector connector = GetConnector(diagram.Connectors, Element.InEdges[0]);
            Node childNode = GetNode(diagram.Nodes, connector.TargetID);
            Parent.DiagramContent.Diagram.BeginUpdate();
            connector.SourceID = Target.ID;            
            if (Target.ID != "rootNode")
                Element.AdditionalInfo["Orientation"] = Target.AdditionalInfo["Orientation"];
            GetOrientation(Target, connector);
            if (edges != null && edges.Count > 0)
            {
                UpdateLayout(edges, Target);
            }
            _ = Parent.DiagramContent.Diagram.EndUpdateAsync();
            await diagram.DoLayoutAsync();
        }
        else { _= Parent.DiagramContent.Diagram.DoLayoutAsync(); }
        bool hasParent = false;
        string parentID = string.Empty;
        for (int i = 0; i < Parent.DiagramContent.TreeViewNodes.Count; i++)
        {
            if (Element.ID == Parent.DiagramContent.TreeViewNodes[i].Id)
            {
                parentID=Parent.DiagramContent.TreeViewNodes[i].ParentId;
                Parent.DiagramContent.TreeViewNodes[i].ParentId = Target.ID;
                for (int j = 0; j < Parent.DiagramContent.TreeViewNodes.Count; j++)
                {
                    if (parentID == Parent.DiagramContent.TreeViewNodes[j].ParentId)
                    {
                        hasParent=true;
                        break;
                    }
                }
                for(int k=0;k<Parent.DiagramContent.TreeViewNodes.Count; k++)
                {
                    if (Target.ID == Parent.DiagramContent.TreeViewNodes[k].Id && !Parent.DiagramContent.TreeViewNodes[k].HasChild)
                    {
                        Parent.DiagramContent.TreeViewNodes[k].HasChild = true;
                        Parent.DiagramContent.TreeViewNodes[k].Expanded = true;
                        List<string> array = new List<string>();
                        String[] emptystring;
                        array.Add(Parent.DiagramContent.TreeViewNodes[k].Id.ToString());
                        emptystring = array.ToArray();
                        await Parent.DiagramContent.Dom.ExpandAllAsync(emptystring);
                    }
                }
            }
           
        }
        if (!hasParent)
        {
            for (int i = 0; i < Parent.DiagramContent.TreeViewNodes.Count; i++)
            {
                if (parentID == Parent.DiagramContent.TreeViewNodes[i].Id && Parent.DiagramContent.TreeViewNodes[i].HasChild)
                {
                    Parent.DiagramContent.TreeViewNodes[i].HasChild = false;
                    Parent.DiagramContent.TreeViewNodes[i].Expanded = false;
                }
            }
        }
       
    }
    /// <summary>
    /// This is used to get the orientation of the element that has to be dropped 
    /// </summary>
    private void GetOrientation(Node target, Connector connector)
    {
        if (Convert.ToString(target.AdditionalInfo["Orientation"]) == "Left")
        {
            connector.SourcePortID = "right";
            connector.TargetPortID = "left";
        }
        else if (Convert.ToString(target.AdditionalInfo["Orientation"]) == "Right")
        {
            connector.SourcePortID = "left";
            connector.TargetPortID = "right";
        }
    }
    /// <summary>
    /// This is used to update orienatation the children and update the layout
    /// </summary>
    private void UpdateLayout(List<string> edges, Node Target)
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        for (int i = 0; i < edges.Count; i++)
        {
            Connector childconnector = GetConnector(diagram.Connectors, edges[i]);
            Node node = GetNode(diagram.Nodes, childconnector.TargetID);
            node.AdditionalInfo["Orientation"] = Target.AdditionalInfo["Orientation"];
            List<string> childEdges = node.OutEdges;
            if (childEdges != null && childEdges.Count > 0)
            {
                UpdateLayout(childEdges, Target);
            }
            GetOrientation(Target, childconnector);
        }
    }
    /// <summary>
    /// This is used to perform undo/redo in a layout
    /// </summary>
    public async Task UndoRedoLayout(Boolean isUndo)
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        if (isUndo)
            diagram.Undo();
        else
        {
            diagram.Redo();
            await diagram.DoLayoutAsync();
        }
        if(diagram.SelectionSettings.Nodes.Count == 0)
        {
            UpdateSelectionForNode(diagram);
        }
    }
    /// <summary>
    /// This is used to update the selection for the node
    /// </summary>
    public void UpdateSelectionForNode(SfDiagramComponent diagram)
    {
        for (int i = 0; i < diagram.Nodes.Count; i++)
        {
            Node newSelection = diagram.Nodes[i];
            if (newSelection.ID == "rootNode")
                diagram.Select(new ObservableCollection<IDiagramObject>() { newSelection });
        }

    }
    /// <summary>
    /// This is used to update the property panel visibilty
    /// </summary>
    public void UpdatePropertyPanel()
    {
        MindMapPropertyVisibility = "none";
        MultipleChildContainerVisibility = "block";
        StateHasChanged();
    }
    /// <summary>
    /// This is used to reposition the slider when the node gets selected
    /// </summary>
    public void slider()
    {
        SfSlide.RepositionAsync();
    }
    public void sliderText()
    {
        OpacitySfSlide.RepositionAsync();
    }
    /// <summary>
    /// This is used to get the orientation of the child entered in text box
    /// </summary>
    public string GetChildOrientation()
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        double leftChildCount = 0;
        double rightChildCount = 0;
        string orientation;
        if(Convert.ToString(diagram.SelectionSettings.Nodes[0].AdditionalInfo["Orientation"]) == "Root")
        {
            for(int i = 0; i < diagram.Nodes.Count; i++)
            {
                if(Convert.ToString(diagram.Nodes[i].AdditionalInfo["Level"]) == "1")
                {
                    if(Convert.ToString(diagram.Nodes[i].AdditionalInfo["Orientation"]) == "Left")
                        leftChildCount++;
                    else
                        rightChildCount++;
                }
            }
            orientation = leftChildCount > rightChildCount ? "Right" : "Left";
        }
        else
        {
            string selectedNodeOrientation = Convert.ToString(diagram.SelectionSettings.Nodes[0].AdditionalInfo["Orientation"]);
            orientation = selectedNodeOrientation;
        }
        return orientation;
    }
    /// <summary>
    /// This is used to split the string by next line which is entered in textbox
    /// </summary>
    private void ValueChangedHandler(String args)
    {
        Children = args.Split("\n");
    }

    /// <summary>
    /// This is used to add child node by entering a values in the txt box
    /// </summary>
    private async void AddChild()
    {
        SfDiagramComponent diagram = Parent.DiagramContent.Diagram;
        diagram.Constraints = DiagramConstraints.Default & ~DiagramConstraints.UndoRedo;
        DiagramObjectCollection<NodeBase> nodes = new DiagramObjectCollection<NodeBase>();
        DiagramObjectCollection<NodeBase> connectors = new DiagramObjectCollection<NodeBase>();
        diagram.BeginUpdate();
        if(diagram.SelectionSettings.Nodes.Count > 0)
        {
            string orientation = GetChildOrientation();
            for(int i = 0; i < Children.Length; i++)
            {
                Node SelectedNode = diagram.SelectionSettings.Nodes[0];
                if (SelectedNode.ID != "rootNode")
                {
                    string selectedNodeOrientation = Convert.ToString(SelectedNode.AdditionalInfo["Orientation"]);
                    orientation = selectedNodeOrientation;
                }
                Dictionary<string, object> MindMapData = new Dictionary<string, object>();
                MindMapData = GetMindMapShape(SelectedNode, string.IsNullOrEmpty(Children[i]) ? "Node" : Children[i]);
                Node node = MindMapData["Node"] as Node;
                AddMindMapLevels("Level" + Convert.ToString(node.AdditionalInfo["Level"]));
                node.ID = "node" + node.ID;
                if (node.AdditionalInfo != null)
                    node.AdditionalInfo["Orientation"] = orientation;
                else
                    node.AdditionalInfo.Add("Orientation", orientation);
                Connector connector = SetConnectorDefault(diagram, orientation, (MindMapData["Connector"] as Connector), SelectedNode.ID, node.ID);
                nodes.Add(node); connectors.Add(connector);

                orientation = Convert.ToString(diagram.SelectionSettings.Nodes[0].AdditionalInfo["Orientation"]) != "Root" ? orientation : orientation == "Left" ? "Right" : "Left";
                for (int j = 0; j < Parent.DiagramContent.TreeViewNodes.Count; j++)
                {
                    if (SelectedNode.ID == Parent.DiagramContent.TreeViewNodes[j].Id)
                    {
                        List<TreeItem> album = new List<TreeItem>();
                        TreeItem Addednode = new TreeItem();
                        Addednode.Id = node.ID;
                        Addednode.Name = node.Annotations[0].Content;
                        Addednode.Expanded = true;
                        Addednode.ParentId = Parent.DiagramContent.TreeViewNodes[j].Id;
                        album.Add(Addednode);
                        Parent.DiagramContent.Dom.AddNodes(album);
                        Parent.DiagramContent.TreeViewNodes.Add(Addednode);
                        for(int k=0; k < Parent.DiagramContent.TreeViewNodes.Count; k++)
                        {
                            if (Parent.DiagramContent.TreeViewNodes[j].Id == Parent.DiagramContent.TreeViewNodes[k].Id)
                            {
                                Parent.DiagramContent.TreeViewNodes[k].HasChild = true;
                                List<string> array = new List<string>();
                                String[] emptystring;
                                array.Add(Parent.DiagramContent.TreeViewNodes[k].Id.ToString());
                                emptystring = array.ToArray();
                                await Parent.DiagramContent.Dom.ExpandAllAsync(emptystring);
                            }
                            
                        }
                    }

                }
            }
            await diagram.AddDiagramElementsAsync(nodes);
            await diagram.AddDiagramElementsAsync(connectors);
            if(PatternChange)
                await MindmapPatternChange(PatternValue);
            await diagram.DoLayoutAsync();
            await diagram.EndUpdateAsync();
            UpdateTextBox();
          diagram.Constraints = DiagramConstraints.Default;
        }       
    }
    private void Cancel()
    {
        UpdateTextBox();
    }
    /// <summary>
    /// This is used to update textbox when add/cancel button clicked
    /// </summary>
    public void UpdateTextBox()
    {
        if(Children != null)
        Array.Clear(Children, 0, Children.Length);
        MindMapPropertyVisibility = "block";
        MultipleChildContainerVisibility = "none";
        textBox.Value = "";
        StateHasChanged();
    }
#pragma warning restore BL0005
}